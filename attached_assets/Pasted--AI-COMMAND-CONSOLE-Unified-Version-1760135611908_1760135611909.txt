# ============================================================
# AI COMMAND CONSOLE (Unified Version)
# ============================================================
#
# Combines:
# - Full conversation logging and structured error handling
# - Bi-directional UE <-> Backend communication
# - Tokenized control routing ([UE_REQUEST] commands)
# - Natural-language wrapping for factual UE responses
# - Immediate ‚ÄúThinking...‚Äù UX state
#
# Compatible with Blueprint flow:
#   Get Text -> Execute Python Command (Advanced):
#       import ai_command_console; ai_command_console.send_and_store('{0}')
#   Delay -> Load File to String (Saved/AIConsole/last_reply.txt) -> Set Text(OutputBox)
#
# ============================================================

import unreal
import requests
import os
import json
import datetime
import traceback
import importlib
from pathlib import Path

# ============================================================
# CONFIGURATION
# ============================================================

API_BASE = "https://ue5-assistant-noahbutcher97.replit.app"
EXECUTE_ENDPOINT = f"{API_BASE}/execute_command"
WRAP_ENDPOINT = f"{API_BASE}/wrap_natural_language"
DESCRIBE_VIEWPORT_ENDPOINT = f"{API_BASE}/describe_viewport"

SAVE_DIR = Path(unreal.Paths.project_saved_dir()) / "AIConsole"
SAVE_DIR.mkdir(parents=True, exist_ok=True)
LAST_REPLY_PATH = SAVE_DIR / "last_reply.txt"
CONV_LOG_PATH = SAVE_DIR / "conversation_log.txt"
LOG_PREFIX = "[AIConsole]"

# ============================================================
# FILE HELPERS
# ============================================================

def _write_text(path: Path, text: str):
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(text)

def _append_text(path: Path, text: str):
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "a", encoding="utf-8") as f:
        f.write(text)

def _timestamp():
    return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def _log_exchange(role: str, text: str):
    entry = {"ts": _timestamp(), "role": role, "text": text}
    _append_text(CONV_LOG_PATH, json.dumps(entry, ensure_ascii=False) + "\n")

def _log(msg: str):
    unreal.log(f"{LOG_PREFIX} {msg}")

# ============================================================
# UX FEEDBACK
# ============================================================

def _write_thinking():
    msg = "‚è≥ Thinking..."
    _write_text(LAST_REPLY_PATH, msg)
    _log(f"Wrote thinking state: {msg}")

# ============================================================
# HTTP HELPERS
# ============================================================

def _post_json(url: str, payload: dict, timeout: float = 25.0) -> dict:
    try:
        r = requests.post(url, json=payload, timeout=timeout)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        _log(f"‚ùå HTTP POST failed: {url} | {e}")
        _log(traceback.format_exc())
        return {"error": str(e)}

# ============================================================
# LOCAL UE ACTIONS
# ============================================================

def _action_list_actors(limit: int = 30) -> str:
    try:
        ell = unreal.EditorLevelLibrary
        actors = list(ell.get_all_level_actors())
        names = [a.get_fname() for a in actors]
        total = len(names)
        lines = [f"Found {total} actors in the current level."]
        for n in names[:limit]:
            lines.append(f" - {n}")
        return "\n".join(lines)
    except Exception as e:
        _log(f"‚ö†Ô∏è list_actors failed: {e}")
        return "[UE_ERROR] list_actors failed."

def _action_get_selected_info() -> str:
    try:
        ell = unreal.EditorLevelLibrary
        sel = list(ell.get_selected_level_actors())
        if not sel:
            return "No actors currently selected."

        out = [f"Selected Actors: {len(sel)}"]
        for a in sel:
            name = a.get_fname()
            cls = a.get_class().get_name() if a.get_class() else "UnknownClass"
            loc = ""
            try:
                t = a.get_root_component().get_component_transform()
                loc = f" at ({round(t.translation.x,1)}, {round(t.translation.y,1)}, {round(t.translation.z,1)})"
            except Exception:
                pass
            out.append(f" - {name} ({cls}){loc}")
        return "\n".join(out)
    except Exception as e:
        _log(f"‚ö†Ô∏è get_selected_info failed: {e}")
        return "[UE_ERROR] get_selected_info failed."

def _handle_describe_viewport() -> str:
    """
    Collect viewport info via describe_viewport.collect_viewport_data(),
    POST to /describe_viewport, and return the summarized text.
    """
    try:
        import describe_viewport
        importlib.reload(describe_viewport)
    except Exception as e:
        _log(f"Cannot import describe_viewport: {e}")
        return "[UE_ERROR] describe_viewport not available."

    try:
        payload = describe_viewport.collect_viewport_data()
        if not payload:
            return "[UE_ERROR] Failed to collect viewport data."

        data = _post_json(DESCRIBE_VIEWPORT_ENDPOINT, payload)
        summary = data.get("response") or data.get("description") or "(no summary)"
        _log("‚úÖ Viewport summary received from backend.")
        return summary
    except Exception as e:
        _log(f"‚ö†Ô∏è Viewport roundtrip failed: {e}")
        return "[UE_ERROR] Viewport summarization failed."

# ============================================================
# NATURAL-LANGUAGE WRAPPING
# ============================================================

def _wrap_natural_language(factual_text: str) -> str:
    """
    Sends factual UE data (e.g. viewport summary) to /wrap_natural_language
    for conversational phrasing.
    """
    if not factual_text:
        return factual_text

    try:
        payload = {"summary": factual_text}
        _log(f"ü™∂ Wrapping factual text ({len(factual_text)} chars)")
        result = _post_json(WRAP_ENDPOINT, payload)
        wrapped = result.get("response", factual_text)
        _log("‚úÖ Natural-language wrapping successful.")
        return wrapped
    except Exception as e:
        _log(f"‚ö†Ô∏è Wrapping failed: {e}")
        return factual_text

# ============================================================
# TOKEN ROUTER
# ============================================================

def _dispatch_control_token(response_text: str) -> str:
    """
    Dispatches backend-issued [UE_REQUEST] tokens to local handlers.
    Applies natural-language wrapping before final output.
    """
    text = (response_text or "").strip()
    if not text.startswith("[UE_REQUEST]"):
        return text

    action = text.replace("[UE_REQUEST]", "").strip().lower()
    _log(f"Dispatching token action: {action}")

    if action == "describe_viewport":
        summary = _handle_describe_viewport()
        # REMOVED: wrapped = _wrap_natural_language(summary)
        _write_text(LAST_REPLY_PATH, summary)
        return summary

    if action == "list_actors":
        summary = _action_list_actors()
        wrapped = _wrap_natural_language(summary)
        _write_text(LAST_REPLY_PATH, wrapped)
        return wrapped

    if action == "get_selected_info":
        summary = _action_get_selected_info()
        wrapped = _wrap_natural_language(summary)
        _write_text(LAST_REPLY_PATH, wrapped)
        return wrapped

    msg = f"[UE_ERROR] Unrecognized UE request: {action}"
    _write_text(LAST_REPLY_PATH, msg)
    return msg

# ============================================================
# CORE REQUEST FLOW
# ============================================================

def send_ai_request(prompt: str) -> str:
    _log(f"Sending to: {EXECUTE_ENDPOINT}")
    data = _post_json(EXECUTE_ENDPOINT, {"prompt": prompt})
    reply = (data or {}).get("response", "")
    _log(f"‚¨ÖÔ∏è Raw response: {reply}")
    return reply

# ============================================================
# MAIN ENTRYPOINT
# ============================================================

def send_and_store(user_text: str):
    """
    Main entrypoint used by the Editor Utility Widget.
    Sends prompt, logs conversation, routes tokens, and writes replies.
    """
    try:
        prompt = str(user_text or "")
        _write_thinking()
        _log_exchange("user", prompt)
        _log(f"üîÑ Sending prompt: {prompt}")

        resp = send_ai_request(prompt)
        final_text = _dispatch_control_token(resp)

        # If not a token, write the raw text
        if not resp.startswith("[UE_REQUEST]"):
            _write_text(LAST_REPLY_PATH, final_text or "(no response)")

        # Log assistant reply
        with open(LAST_REPLY_PATH, "r", encoding="utf-8") as f:
            assistant_text = f.read().strip()
        _log_exchange("assistant", assistant_text)
        _log(f"‚úÖ Reply written to {LAST_REPLY_PATH}")
        return assistant_text

    except Exception as e:
        _log(f"‚ùå send_and_store failed: {e}")
        _log(traceback.format_exc())
        msg = f"[UE_ERROR] send_and_store failed: {e}"
        _write_text(LAST_REPLY_PATH, msg)
        return msg
